# Union-Find set
#### 实现细节  
用数组存储每个节点的根节点，即 `id[j]`，其中j表示一个节点的序号。
用size数组存储以某个节点为根的树的大小。

#### quick-find
find过程时间复杂度为O(1),因为在union过程中有较多操作，即每次union节点i和j时，若i≠j，则把所有指向j的节点（包括j）指向i，形成一棵一层的树。

#### quick-union
union过程时间复杂度为O(1),只需把i的根连到j的根即可，因为在find过程中有较多操作，即每次都要从一个节点沿着树往上找到其根节点。

#### 加权quick-union 
union过程中将size小的堆连接到size大的堆，这样可以保证对于节点数为N的树，其高度不超过longN。

#### 加权路径压缩quick-union
在加权quick-union的基础上，在find的过程中，将find路径上的每个节点都连接到它所在的树的根节点，实验证明，这很有效。而且这是已知的最有方法。

#### 时间复杂度证明